## Http演化

#### 最初的HTTP

HTTP/0.9 单行协议

最初的HTTP协议并没有版本号，后来它的版本号定位在0.9以区分后来的版本。

HTTP/0.9极其简单，请求由单行指令构成，以唯一可以方法`GET`开头，其后跟目标资源的路径。



==HTTP协议中只要求路径是因为，http协议是应用层协议，应用层协议并不需要关注IP地址，端口号这些东西，一旦连接建立，这些都是固定的==

##### 请求

`GET /somepage.html`

响应

`<HTML> content <\HTML>`

最初的HTTP协议十分简单，因此功能也十分单一。

其主要缺点有

- 无法判断执行的状态，只能人工查看返回的html内容
- 只有GET一个方法，只能适用于简单的获取html页面的场景
- 只能发出请求，接受文件，并不能附加任何信息

---

#### HTTP/1.0

随着对协议功能需求的增加，人们对HTTP进行了扩展。HTTP/1.0并不是官方标准。

- 发送
  - 增加了HTTP头来显示控制信息
    - 增加了多个请求方法，以适应不同的要求
    - 增加HTTP版本的信息(兼容性)
  - 增加了Headers部分，使的http具更好的扩展性
- 响应
  - 增加了状态码使得浏览器(用户代理)可以根据响应报文进行相应的处理

HTTP/1.0在原有的协议的基础上改进了许多，使得整个协议更好的适应越来越多样化的用户需求，也提供了更好的扩展性。但还是有一些不足：

- HTTP/1.0，不能够保持连接，一个请求，响应过程就需要建立一个连接。在一个用户进行多个请求时，比如一个网页有多个资源时。就会反复建立连接影响性能。
- HTTP/1.0，不能只请求一个资源的一部分，一旦请求就必须获取全部资源，会造成网络资源的浪费。

#### HTTP/1.1

HTTP/1.1是一个标准化版本，对HTTP/1.0进行了多项修改

- 性能优化
  - 支持长连接，避免多次重复建立TCP连接造成的资源浪费
  - 支持请求资源的一部分，避免了整个文件传输
  - 引入了额外的缓存控制机制
  - 增加管线化技术，允许在前一个请求的响应被完全响应之前就发送第二个请求。
- 引入了Host头，使得不同的域名可以被配置在同一个IP地址的服务器上

#### HTTP/1.x的连接管理

![](https://markdown-1259282458.cos.ap-nanjing.myqcloud.com/img/20210728221453.png)

HTTP/1.0采用的是短连接的方式，即为每个请求建立连接，在发送响应报文之后断开连接。这样做在用户连续发送请求，或用户请求一个复杂网页时，需要反复执行创建连接和关闭连接的过程，造成了资源的浪费。

因此在HTTP/1.1中默认了长连接，以避免反复的建立和断开TCP连接。



此外，在默认情况下，HTTP请求是顺序发送的，即只有收到上一个请求的响应报文，才会发送下一个请求。因此可能会因为网络延迟等原因导致后续请求长时间等待。

HTTP/1.1引入了流水线技术，使得你不需要等待上一个请求的响应之后，再发送下一个请求。*但是在服务器端还是按顺序对请求进行处理的*。



同时HTTP/1.1还有引入了域名分片技术，通过域名分片使得浏览器建立多个与服务器的连接，进而并行的进行数据的发送。

---

#### HTTP/2.0

HTTP/1.1是1997年发布的，近些年来，网页变得越来越复杂，一个网页可能有多个功能。使用HTTP/1.1来进行传输可以就需要使用多个连接来进行并行处理，复杂性和难度都比较大。因此HTTP/2.0应运而生。

HTTP/2.0与HTTP/1.1的主要区别

- HTTP/2.0可以对一个连接进行多路复用，避免了HTTP/1.1的多连接情况。
  - 对一条TCP连接进行复用，避免了建立多条TCP连接可能出现的闲置浪费资源的情况，同时也避免因为TCP慢开始导致的冷启动较慢的问题
- HTTP/2.0是一个二进制协议，不再是明文传输
- 可以对Headers进行压缩，通过服务器与客户端进行协商，可以避免在长连接中，反复传输改变较少的Headers，以此来提高传输效率
- 即服务端向客户端发送比客户端请求更多的数据。这允许服务器直接提供浏览器渲染页面所需资源，而无须浏览器在收到、解析页面后再提起一轮请求，节约了加载时间。

##### 多路复用

HTTP/1.1中使用管线化的方式，对请求响应进行了优化，但是它还是没有解决先发送的包丢失了会阻塞之后的请求的问题。同时HTTP/1.1使用域名分片海建立多个连接实现并行数据传输，但是这样的解决方法有两个问题

1. 需要建立多个连接，维持多个连接，会占用系统资源
2. 有的连接如果请求较少的话，会遇到启动速度较慢导致的性能问题。

因此在HTTP/2.0中选择对单条TCP连接进行复用来解决这些问题。

HTTP/2.0中将一条TCP连接分为不同的Stream，将数据封装成帧在流中传输，不同的数据使用不同的流，这样不需要建立新的TCP连接，且不会因为链接闲置导致慢启动的问题。

##### 头部压缩

在一个持久的链接中，服务器与客户端需要反复的进行请求/响应的过程，在这个情况下，报文中的Headers就会被反复传输，若能够对Headers进行压缩就能够提升整个网络的利用率。

Headers是`name:value`的键值对集合，而在一个连接中，大部分Header是不会发生变化的。因此HTTP/2.0，使用字典对Headers进行压缩，以提高网络的利用率。



HTTP/2.0使用HPACK进行压缩，主要有三种压缩方法

- 静态字典：预定义的字典，包含一些常用的`name:value`对
- 动态字典：FIFO的字典表，用于存储一些实际遇到的`name:value`,这样在下一次发送时就能压缩
- 霍夫曼编码：用静态霍夫曼编码对字符串进行压缩



其压缩策略是：

- `name:value`:都能在字典中找到的就使用字典中的内容进行压缩
- `value`找不到，而`name`找得到，`name`就用字典中的结果，`value`先不进行压缩，将霍夫曼编码结果加入字典，下一次发送使用。

---

#### HTTP/3.0

HTTP协议是一个应用层协议，一直是采用TCP作为运输层协议。然而HTTP对于运输层协议的要求只有一个即能够保证可靠性。而使用TCP作为运输层协议，就会因为其一些其他的性质导致性能瓶颈。因此在HTTP/3.0中，弃用了TCP，选择了基于UDP的QUIC协议实现。

---

##### Reference

- [Http演化](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Basics_of_HTTP/Evolution_of_HTTP)
- [HPACK](https://blog.cloudflare.com/hpack-the-silent-killer-feature-of-http-2/)



